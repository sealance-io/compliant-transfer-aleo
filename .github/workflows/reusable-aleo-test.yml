name: Reusable Aleo Test

on:
  workflow_call:
    inputs:
      test_command:
        required: true
        type: string
        description: "The test command to run"
      watched_paths:
        required: true
        type: string
        description: "Comma-separated list of paths to watch for changes"
      job_name:
        required: true
        type: string
        description: "Name of the job displayed in GitHub UI"

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0 # Need full history for comparing commits

      - name: Check if paths changed
        id: check
        run: |
          # If workflow dispatch, always run
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get changed files
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})

          # Check if any watched paths were changed
          SHOULD_RUN=false
          IFS=',' read -ra PATHS <<< "${{ inputs.watched_paths }}"
          for path in "${PATHS[@]}"; do
            if echo "$CHANGED_FILES" | grep -q "$path"; then
              SHOULD_RUN=true
              echo "Path '$path' was modified, triggering test"
              break
            fi
          done

          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT

  run-test:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.should_run == 'true' }}
    name: ${{ inputs.job_name }}
    runs-on: ubuntu-latest
    env:
      DEVNET_CHECK_TIMEOUT: 720000 # 12 minutes in ms
      DEVNET_CHECK_INTERVAL: 5000 # 5 seconds in ms
      # TODO: Consolidate these 2 env vars
      DEVNET_ENDPOINT: "http://host.docker.internal:3030"
      TESTNET_ENDPOINT: "http://host.docker.internal:3030"
    permissions:
      contents: "read"
      packages: "read"
      actions: "read"
    timeout-minutes: 180
    container:
      image: ghcr.io/sealance-io/leo-lang-ci:v3.1.0
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.github_token }}
      options: --cpus 2 --add-host=host.docker.internal:host-gateway
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
    steps:
      - uses: actions/checkout@v4
      - name: Setup doko-js-cli
        uses: sealance-io/setup-doko-js-action@v0.1.0
        with:
          doko-repo: "sealance-io/doko-js"
          doko-branch: "fixes_to_dokojs"
      - uses: actions/setup-node@v4
        with:
          node-version-file: ".nvmrc"
          cache: "npm"
          cache-dependency-path: "./package-lock.json"

      - run: cp .env.example .env

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --no-fund --ignore-scripts && npm run postinstall

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull aleo-devnet image
        run: docker pull ghcr.io/sealance-io/aleo-devnet:v3.1.0-v4.1.0

      # Start devnet since compiling will try to fetch 'credits.aleo'
      - name: Start aleo-devnet
        run: docker run -it -d -p 3030:3030 ghcr.io/sealance-io/aleo-devnet:v3.1.0-v4.1.0

      # Wait for 'credit.aleo' to fetch-able
      - name: Wait for Aleo Devnet Ready
        shell: bash
        run: |
          # strict mode
          set -euo pipefail

          # Configuration with defaults
          DEVNET_ENDPOINT="${DEVNET_ENDPOINT:-http://host.docker.internal:3030}"
          TIMEOUT="${DEVNET_CHECK_TIMEOUT:-180000}"  # in milliseconds
          INTERVAL="${DEVNET_CHECK_INTERVAL:-5000}"   # in milliseconds

          # Parse DEVNET_ENDPOINT to extract host and port
          # Remove http:// or https:// prefix if present
          ENDPOINT_CLEAN="${DEVNET_ENDPOINT#http://}"
          ENDPOINT_CLEAN="${ENDPOINT_CLEAN#https://}"

          # Extract host and port using POSIX-compliant methods
          if echo "$ENDPOINT_CLEAN" | grep -q ":"; then
              HOST=$(echo "$ENDPOINT_CLEAN" | cut -d: -f1)
              PORT=$(echo "$ENDPOINT_CLEAN" | cut -d: -f2 | cut -d/ -f1)
          else
              HOST="$ENDPOINT_CLEAN"
              PORT="3030"  # Default to 3030 if no port specified
          fi

          # Special handling for host.docker.internal
          # In GitHub Actions runners, this should be replaced with localhost
          if [ "$HOST" = "host.docker.internal" ]; then
              # Check if we're inside a container
              if [ -f /.dockerenv ]; then
                  echo "Running inside Docker, using host.docker.internal"
              else
                  echo "Not in Docker, converting host.docker.internal to localhost"
                  HOST="localhost"
              fi
          fi

          # Validate port is a number using grep
          if ! echo "$PORT" | grep -qE '^[0-9]+$'; then
              echo "Error: Invalid port number: $PORT"
              exit 1
          fi

          # Convert milliseconds to seconds for bash
          TIMEOUT_SEC=$((TIMEOUT / 1000))
          INTERVAL_SEC=$((INTERVAL / 1000))

          # API endpoint
          API_URL="http://${HOST}:${PORT}/testnet/program/credits.aleo"

          echo "Waiting for Aleo devnet to be ready at ${API_URL}"
          echo "Endpoint: ${DEVNET_ENDPOINT} (using ${HOST}:${PORT})"
          echo "Timeout: ${TIMEOUT}ms (${TIMEOUT_SEC}s), Check interval: ${INTERVAL}ms (${INTERVAL_SEC}s)"

          # Track start time
          START_TIME=$(date +%s)

          # Main polling loop
          while true; do
              # Calculate elapsed time
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              # Check timeout
              if [ "$ELAPSED" -ge "$TIMEOUT_SEC" ]; then
                  echo "❌ Timeout waiting for Aleo devnet to be ready."
                  echo "Waited ${TIMEOUT}ms but devnet did not respond with credits.aleo program."
                  exit 1
              fi
              
              # Try to fetch the credits.aleo program
              HTTP_STATUS=""
              RESPONSE=""
              
              # Use set +e temporarily to handle curl failures gracefully
              set +e
              FULL_RESPONSE=$(curl -s -w "\n%{http_code}" -m 5 "${API_URL}" 2>/dev/null)
              CURL_EXIT=$?
              set -e
              
              if [ "$CURL_EXIT" -eq 0 ]; then
                  # Split response body and HTTP status code
                  HTTP_STATUS=$(echo "$FULL_RESPONSE" | tail -n 1)
                  RESPONSE=$(echo "$FULL_RESPONSE" | head -n -1)
                  
                  # Check if we got a successful HTTP status (2xx)
                  if echo "$HTTP_STATUS" | grep -qE '^2[0-9][0-9]$'; then
                      # Check if response is non-empty (ignoring whitespace)
                      TRIMMED_RESPONSE=$(echo "$RESPONSE" | tr -d '[:space:]')
                      
                      if [ -n "$TRIMMED_RESPONSE" ]; then
                          echo "✅ Aleo devnet is ready! HTTP ${HTTP_STATUS} - credits.aleo program loaded"
                          echo "Response preview: $(echo "$RESPONSE" | head -c 100)..."
                          exit 0
                      else
                          echo "[${ELAPSED}s] HTTP ${HTTP_STATUS} but empty response - devnet still initializing..."
                      fi
                  elif [ -n "$HTTP_STATUS" ]; then
                      # Got an HTTP error code
                      echo "[${ELAPSED}s] HTTP ${HTTP_STATUS} - waiting for devnet to be ready..."
                  else
                      # No HTTP status code received
                      echo "[${ELAPSED}s] No response - waiting for devnet API..."
                  fi
              else
                  # Network error - expected initially while devnet is starting
                  echo "[${ELAPSED}s] Connection failed - waiting for devnet to start..."
              fi
              
              # Wait before next check
              sleep "$INTERVAL_SEC"
          done

      - name: Compile leo
        run: npm run compile

      - name: Run test (bypass test-containers)
        run: ${{ inputs.test_command }}
        env:
          DOCKER_HOST: "unix:///var/run/docker.sock"
          TESTCONTAINERS_RYUK_DISABLED: true
          USE_TEST_CONTAINERS: 0

      - name: Stop aleo-devnet
        if: always() # Run even if previous steps fails for cleanup
        run: |
          docker ps -q | tr ' ' '\n' | xargs -I {} docker stop {}
          docker ps -a -q | tr ' ' '\n' | xargs -I {} docker rm {}
