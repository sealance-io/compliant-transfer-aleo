name: Reusable Aleo Test

on:
  workflow_call:
    inputs:
      test_command:
        required: true
        type: string
        description: "The test command to run"
      watched_paths:
        required: true
        type: string
        description: "Comma-separated list of paths to watch for changes"
      job_name:
        required: true
        type: string
        description: "Name of the job displayed in GitHub UI"

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0 # Need full history for comparing commits

      - name: Check if paths changed
        id: check
        run: |
          # If workflow dispatch, always run
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get changed files
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})

          # Check if any watched paths were changed
          SHOULD_RUN=false
          IFS=',' read -ra PATHS <<< "${{ inputs.watched_paths }}"
          for path in "${PATHS[@]}"; do
            if echo "$CHANGED_FILES" | grep -q "$path"; then
              SHOULD_RUN=true
              echo "Path '$path' was modified, triggering test"
              break
            fi
          done

          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT

  run-test:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.should_run == 'true' }}
    name: ${{ inputs.job_name }}
    runs-on: ubuntu-latest
    env:
      DEVNET_CHECK_TIMEOUT: 720000  # 12 minutes in ms
      DEVNET_CHECK_INTERVAL: 5000   # 5 seconds in ms
      PORT: 3030
    permissions:
      contents: "read"
      packages: "read"
      actions: "read"
    timeout-minutes: 180
    container:
      image: ghcr.io/sealance-io/leo-lang-ci:v2.6.1
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.github_token }}
      options: --cpus 2 --add-host=host.docker.internal:host-gateway
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
    steps:
      - uses: actions/checkout@v4
      - name: Setup doko-js-cli
        uses: sealance-io/setup-doko-js-action@v0.1.0
        with:
          doko-repo: "sealance-io/doko-js"
          doko-branch: "0ae61e5854006dbc6dcc1fe5d7f9f39a2e1648e4"
      - uses: actions/setup-node@v4
        with:
          node-version-file: ".nvmrc"
          cache: "npm"
          cache-dependency-path: "./package-lock.json"

      - run: cp .env.example .env

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --no-fund --ignore-scripts && npm run postinstall

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull aleo-devnet image
        run: docker pull ghcr.io/sealance-io/aleo-devnet:v3.1.0-v4.1.0

      # Start devnet since compiling will try to fetch 'credits.aleo'
      - name: Start aleo-devnet
        run: docker run -it -d -p 3030:3030 ghcr.io/sealance-io/aleo-devnet:v3.1.0-v4.1.0

      # Wait for 'credit.aleo' to fetch-able
      - name: Wait for Aleo Devnet Ready
        run: |
          # Wait for credits.aleo program to be available
          PORT="${PORT:-3030}"
          TIMEOUT="${DEVNET_CHECK_TIMEOUT:-180000}"
          INTERVAL="${DEVNET_CHECK_INTERVAL:-5000}"
          
          TIMEOUT_SEC=$((TIMEOUT / 1000))
          INTERVAL_SEC=$((INTERVAL / 1000))
          API_URL="http://localhost:${PORT}/testnet/program/credits.aleo"
          
          echo "Waiting for Aleo devnet to be ready at ${API_URL}"
          echo "Timeout: ${TIMEOUT}ms, Check interval: ${INTERVAL}ms"
          
          START_TIME=$(date +%s)
          
          while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              if [ $ELAPSED -ge $TIMEOUT_SEC ]; then
                  echo "❌ Timeout waiting for Aleo devnet to be ready."
                  exit 1
              fi
              
              # Get both HTTP status and response body
              if FULL_RESPONSE=$(curl -s -w "\n%{http_code}" -m 5 "${API_URL}" 2>/dev/null); then
                  HTTP_STATUS=$(echo "$FULL_RESPONSE" | tail -n 1)
                  RESPONSE=$(echo "$FULL_RESPONSE" | head -n -1)
                  
                  # Check for successful HTTP status (2xx) and non-empty response
                  if [[ "$HTTP_STATUS" =~ ^2[0-9][0-9]$ ]]; then
                      TRIMMED_RESPONSE=$(echo "$RESPONSE" | tr -d '[:space:]')
                      
                      if [[ -n "$TRIMMED_RESPONSE" ]]; then
                          echo "✅ Aleo devnet is ready! HTTP ${HTTP_STATUS} - credits.aleo program loaded"
                          break
                      else
                          echo "[${ELAPSED}s] HTTP ${HTTP_STATUS} but empty response - devnet still initializing..."
                      fi
                  elif [[ -n "$HTTP_STATUS" ]]; then
                      echo "[${ELAPSED}s] HTTP ${HTTP_STATUS} - waiting for devnet to be ready..."
                  fi
              else
                  echo "[${ELAPSED}s] Connection failed - waiting for devnet to start..."
              fi
              
              sleep $INTERVAL_SEC
          done

      - name: Compile leo
        run: npm run compile

      - name: Run test (bypass test-containers)
        run: ${{ inputs.test_command }}
        env:
          DOCKER_HOST: "unix:///var/run/docker.sock"
          TESTCONTAINERS_RYUK_DISABLED: true
          TESTNET_ENDPOINT: "http://host.docker.internal:3030"
          USE_TEST_CONTAINERS: 0

      - name: Stop aleo-devnet
        if: always() # Run even if previous steps fails for cleanup
        run: |
          docker ps -q | tr ' ' '\n' | xargs -I {} docker stop {}
          docker ps -a -q | tr ' ' '\n' | xargs -I {} docker rm {}
